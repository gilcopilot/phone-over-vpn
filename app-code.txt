// MainActivity.kt
package com.example.openvpnsmshandler

import android.Manifest
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Bundle
import android.telephony.SmsManager
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.core.content.ContextCompat
import androidx.lifecycle.viewmodel.compose.viewModel
import com.example.openvpnsmshandler.ui.theme.OpenVPNSMSHandlerTheme

class MainActivity : ComponentActivity() {
    private val requestPermissions = registerForActivityResult(
        ActivityResultContracts.RequestMultiplePermissions()
    ) { permissions ->
        val allGranted = permissions.values.all { it }
        if (allGranted) {
            Toast.makeText(this, "All permissions granted", Toast.LENGTH_SHORT).show()
        } else {
            Toast.makeText(this, "Some permissions denied", Toast.LENGTH_SHORT).show()
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        checkAndRequestPermissions()
        
        setContent {
            OpenVPNSMSHandlerTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    MainScreen()
                }
            }
        }
    }

    private fun checkAndRequestPermissions() {
        val permissions = arrayOf(
            Manifest.permission.SEND_SMS,
            Manifest.permission.READ_SMS,
            Manifest.permission.CALL_PHONE,
            Manifest.permission.READ_PHONE_STATE,
            Manifest.permission.INTERNET,
            Manifest.permission.ACCESS_NETWORK_STATE
        )

        val permissionsToRequest = permissions.filter {
            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED
        }

        if (permissionsToRequest.isNotEmpty()) {
            requestPermissions.launch(permissionsToRequest.toTypedArray())
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MainScreen(viewModel: MainViewModel = viewModel()) {
    val context = LocalContext.current
    val uiState by viewModel.uiState.collectAsState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        // Header
        Card(
            modifier = Modifier.fillMaxWidth(),
            colors = CardDefaults.cardColors(
                containerColor = if (uiState.isVpnConnected) 
                    Color(0xFF4CAF50) else Color(0xFFFF5722)
            )
        ) {
            Column(
                modifier = Modifier.padding(16.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    text = "OpenVPN SMS/Call Handler",
                    style = MaterialTheme.typography.headlineSmall,
                    color = Color.White,
                    fontWeight = FontWeight.Bold
                )
                Spacer(modifier = Modifier.height(8.dp))
                Text(
                    text = if (uiState.isVpnConnected) "Connected" else "Disconnected",
                    style = MaterialTheme.typography.bodyLarge,
                    color = Color.White
                )
            }
        }

        Spacer(modifier = Modifier.height(16.dp))

        // VPN Configuration
        Card(modifier = Modifier.fillMaxWidth()) {
            Column(modifier = Modifier.padding(16.dp)) {
                Text(
                    text = "VPN Configuration",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                Spacer(modifier = Modifier.height(8.dp))
                
                OutlinedTextField(
                    value = uiState.serverAddress,
                    onValueChange = viewModel::updateServerAddress,
                    label = { Text("Server Address") },
                    modifier = Modifier.fillMaxWidth()
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                OutlinedTextField(
                    value = uiState.serverPort,
                    onValueChange = viewModel::updateServerPort,
                    label = { Text("Port") },
                    modifier = Modifier.fillMaxWidth()
                )
                
                Spacer(modifier = Modifier.height(16.dp))
                
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Button(
                        onClick = { viewModel.connectVPN(context) },
                        enabled = !uiState.isVpnConnected,
                        modifier = Modifier.weight(1f)
                    ) {
                        Text("Connect VPN")
                    }
                    
                    Button(
                        onClick = { viewModel.disconnectVPN() },
                        enabled = uiState.isVpnConnected,
                        modifier = Modifier.weight(1f),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = MaterialTheme.colorScheme.error
                        )
                    ) {
                        Text("Disconnect")
                    }
                }
            }
        }

        Spacer(modifier = Modifier.height(16.dp))

        // Status and Logs
        Card(modifier = Modifier.fillMaxWidth()) {
            Column(modifier = Modifier.padding(16.dp)) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = "Activity Log",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold
                    )
                    
                    TextButton(onClick = viewModel::clearLogs) {
                        Text("Clear")
                    }
                }
                
                Spacer(modifier = Modifier.height(8.dp))
                
                LazyColumn(
                    modifier = Modifier.height(200.dp),
                    reverseLayout = true
                ) {
                    items(uiState.logs) { log ->
                        Text(
                            text = log,
                            style = MaterialTheme.typography.bodySmall,
                            modifier = Modifier.padding(vertical = 2.dp)
                        )
                    }
                }
            }
        }

        Spacer(modifier = Modifier.height(16.dp))

        // Statistics
        Card(modifier = Modifier.fillMaxWidth()) {
            Column(modifier = Modifier.padding(16.dp)) {
                Text(
                    text = "Statistics",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                Spacer(modifier = Modifier.height(8.dp))
                
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceEvenly
                ) {
                    StatItem("SMS Sent", uiState.smsSentCount.toString())
                    StatItem("Calls Made", uiState.callsMadeCount.toString())
                    StatItem("Requests", uiState.totalRequests.toString())
                }
            }
        }
    }
}

@Composable
fun StatItem(label: String, value: String) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(
            text = value,
            style = MaterialTheme.typography.headlineMedium,
            fontWeight = FontWeight.Bold,
            color = MaterialTheme.colorScheme.primary
        )
        Text(
            text = label,
            style = MaterialTheme.typography.bodySmall
        )
    }
}

// MainViewModel.kt
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.telephony.SmsManager
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*

data class UiState(
    val isVpnConnected: Boolean = false,
    val serverAddress: String = "",
    val serverPort: String = "1194",
    val logs: List<String> = emptyList(),
    val smsSentCount: Int = 0,
    val callsMadeCount: Int = 0,
    val totalRequests: Int = 0
)

class MainViewModel : ViewModel() {
    private val _uiState = MutableStateFlow(UiState())
    val uiState: StateFlow<UiState> = _uiState.asStateFlow()

    private val vpnClient = OpenVPNClient()
    private val httpServer = HTTPServer()

    init {
        // Start HTTP server to listen for requests
        startHTTPServer()
    }

    fun updateServerAddress(address: String) {
        _uiState.value = _uiState.value.copy(serverAddress = address)
    }

    fun updateServerPort(port: String) {
        _uiState.value = _uiState.value.copy(serverPort = port)
    }

    fun connectVPN(context: Context) {
        viewModelScope.launch {
            try {
                addLog("Connecting to VPN...")
                val success = vpnClient.connect(
                    _uiState.value.serverAddress,
                    _uiState.value.serverPort.toInt()
                )
                
                if (success) {
                    _uiState.value = _uiState.value.copy(isVpnConnected = true)
                    addLog("VPN connected successfully")
                } else {
                    addLog("VPN connection failed")
                }
            } catch (e: Exception) {
                addLog("VPN connection error: ${e.message}")
            }
        }
    }

    fun disconnectVPN() {
        viewModelScope.launch {
            try {
                vpnClient.disconnect()
                _uiState.value = _uiState.value.copy(isVpnConnected = false)
                addLog("VPN disconnected")
            } catch (e: Exception) {
                addLog("VPN disconnection error: ${e.message}")
            }
        }
    }

    fun clearLogs() {
        _uiState.value = _uiState.value.copy(logs = emptyList())
    }

    private fun startHTTPServer() {
        viewModelScope.launch {
            try {
                httpServer.start(8080) { request ->
                    handleIncomingRequest(request)
                }
                addLog("HTTP server started on port 8080")
            } catch (e: Exception) {
                addLog("Failed to start HTTP server: ${e.message}")
            }
        }
    }

    private fun handleIncomingRequest(request: HTTPRequest) {
        viewModelScope.launch {
            try {
                _uiState.value = _uiState.value.copy(
                    totalRequests = _uiState.value.totalRequests + 1
                )
                
                when (request.type) {
                    "SMS" -> {
                        sendSMS(request.phoneNumber, request.message)
                        _uiState.value = _uiState.value.copy(
                            smsSentCount = _uiState.value.smsSentCount + 1
                        )
                    }
                    "CALL" -> {
                        makeCall(request.phoneNumber)
                        _uiState.value = _uiState.value.copy(
                            callsMadeCount = _uiState.value.callsMadeCount + 1
                        )
                    }
                }
                
                addLog("Processed ${request.type} request for ${request.phoneNumber}")
            } catch (e: Exception) {
                addLog("Error processing request: ${e.message}")
            }
        }
    }

    private fun sendSMS(phoneNumber: String, message: String) {
        try {
            val smsManager = SmsManager.getDefault()
            smsManager.sendTextMessage(phoneNumber, null, message, null, null)
            addLog("SMS sent to $phoneNumber")
        } catch (e: Exception) {
            addLog("SMS sending failed: ${e.message}")
        }
    }

    private fun makeCall(phoneNumber: String) {
        try {
            // Note: This would require CALL_PHONE permission and context
            addLog("Call initiated to $phoneNumber")
        } catch (e: Exception) {
            addLog("Call failed: ${e.message}")
        }
    }

    private fun addLog(message: String) {
        val timestamp = SimpleDateFormat("HH:mm:ss", Locale.getDefault()).format(Date())
        val logEntry = "[$timestamp] $message"
        
        val currentLogs = _uiState.value.logs.toMutableList()
        currentLogs.add(0, logEntry)
        
        // Keep only last 100 logs
        if (currentLogs.size > 100) {
            currentLogs.removeAt(currentLogs.size - 1)
        }
        
        _uiState.value = _uiState.value.copy(logs = currentLogs)
    }
}

// OpenVPNClient.kt
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.net.Socket
import javax.net.ssl.SSLSocket
import javax.net.ssl.SSLSocketFactory

class OpenVPNClient {
    private var socket: Socket? = null
    private var isConnected = false

    suspend fun connect(serverAddress: String, port: Int): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                // Create SSL socket for secure OpenVPN connection
                val socketFactory = SSLSocketFactory.getDefault()
                socket = socketFactory.createSocket(serverAddress, port) as SSLSocket
                
                // Perform OpenVPN handshake here
                performHandshake()
                
                isConnected = true
                true
            } catch (e: Exception) {
                isConnected = false
                false
            }
        }
    }

    suspend fun disconnect() {
        withContext(Dispatchers.IO) {
            try {
                socket?.close()
                socket = null
                isConnected = false
            } catch (e: Exception) {
                // Handle disconnect error
            }
        }
    }

    private fun performHandshake() {
        // Implement OpenVPN handshake protocol
        // This is a simplified version - real implementation would be more complex
        socket?.let { sock ->
            val output = sock.getOutputStream()
            val input = sock.getInputStream()
            
            // Send client hello
            val clientHello = "CLIENT_HELLO"
            output.write(clientHello.toByteArray())
            output.flush()
            
            // Read server response
            val buffer = ByteArray(1024)
            val bytesRead = input.read(buffer)
            val response = String(buffer, 0, bytesRead)
            
            // Process server response and complete handshake
        }
    }

    fun isConnected(): Boolean = isConnected
}

// HTTPServer.kt
import kotlinx.coroutines.*
import java.io.*
import java.net.ServerSocket
import java.net.Socket
import com.google.gson.Gson
import com.google.gson.annotations.SerializedName

data class HTTPRequest(
    @SerializedName("type") val type: String,
    @SerializedName("phone_number") val phoneNumber: String,
    @SerializedName("message") val message: String = ""
)

class HTTPServer {
    private var serverSocket: ServerSocket? = null
    private var isRunning = false
    private val gson = Gson()

    suspend fun start(port: Int, requestHandler: (HTTPRequest) -> Unit) {
        withContext(Dispatchers.IO) {
            try {
                serverSocket = ServerSocket(port)
                isRunning = true
                
                while (isRunning) {
                    val clientSocket = serverSocket?.accept()
                    clientSocket?.let { socket ->
                        // Handle each client in a separate coroutine
                        launch {
                            handleClient(socket, requestHandler)
                        }
                    }
                }
            } catch (e: Exception) {
                // Handle server error
            }
        }
    }

    private suspend fun handleClient(socket: Socket, requestHandler: (HTTPRequest) -> Unit) {
        withContext(Dispatchers.IO) {
            try {
                val reader = BufferedReader(InputStreamReader(socket.getInputStream()))
                val writer = PrintWriter(socket.getOutputStream(), true)
                
                // Read HTTP request
                val requestLine = reader.readLine()
                val headers = mutableMapOf<String, String>()
                var line: String?
                
                // Read headers
                while (reader.readLine().also { line = it } != null && line!!.isNotEmpty()) {
                    val parts = line!!.split(": ", limit = 2)
                    if (parts.size == 2) {
                        headers[parts[0]] = parts[1]
                    }
                }
                
                // Read body if POST request
                var body = ""
                if (requestLine.contains("POST")) {
                    val contentLength = headers["Content-Length"]?.toIntOrNull() ?: 0
                    if (contentLength > 0) {
                        val bodyChars = CharArray(contentLength)
                        reader.read(bodyChars)
                        body = String(bodyChars)
                    }
                }
                
                // Parse request and handle
                if (body.isNotEmpty()) {
                    try {
                        val request = gson.fromJson(body, HTTPRequest::class.java)
                        requestHandler(request)
                        
                        // Send success response
                        writer.println("HTTP/1.1 200 OK")
                        writer.println("Content-Type: application/json")
                        writer.println("Connection: close")
                        writer.println()
                        writer.println("{\"status\":\"success\"}")
                    } catch (e: Exception) {
                        // Send error response
                        writer.println("HTTP/1.1 400 Bad Request")
                        writer.println("Content-Type: application/json")
                        writer.println("Connection: close")
                        writer.println()
                        writer.println("{\"status\":\"error\",\"message\":\"${e.message}\"}")
                    }
                } else {
                    // Send method not allowed
                    writer.println("HTTP/1.1 405 Method Not Allowed")
                    writer.println("Connection: close")
                    writer.println()
                }
                
                socket.close()
            } catch (e: Exception) {
                // Handle client error
            }
        }
    }

    fun stop() {
        isRunning = false
        serverSocket?.close()
    }
}

// Theme.kt
package com.example.openvpnsmshandler.ui.theme

import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable

private val DarkColorScheme = darkColorScheme(
    primary = androidx.compose.ui.graphics.Color(0xFF6200EE),
    secondary = androidx.compose.ui.graphics.Color(0xFF03DAC5)
)

private val LightColorScheme = lightColorScheme(
    primary = androidx.compose.ui.graphics.Color(0xFF6200EE),
    secondary = androidx.compose.ui.graphics.Color(0xFF03DAC5)
)

@Composable
fun OpenVPNSMSHandlerTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = MaterialTheme.typography,
        content = content
    )
}